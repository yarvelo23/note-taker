#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_extra_1 = require("fs-extra");
const image_size_1 = require("image-size");
const meow_1 = __importDefault(require("meow"));
const sharp_1 = __importDefault(require("sharp"));
const ICON_SIZE_DELIMITER = ',';
const MIN_ACCEPT_IMAGE_RESOLUTION = 512;
const DEFAULT_INPUT_ICON_PATH = 'public/icon.svg';
const DEFAULT_INPUT_MANIFEST_PATH = 'public/manifest.webmanifest';
const DEFAULT_OUTPUT_ICON_PATH = 'public/assets';
const DEFAULT_OUTPUT_MANIFEST_PATH = 'public/manifest.webmanifest';
const DEFAULT_OUTPUT_SIZES = '512,384,192,180,152,144,128,96,72';
!(() => __awaiter(void 0, void 0, void 0, function* () {
    const cli = meow_1.default(`
  Usage
    $ webmanifest --icon <filepath>

  Options
    --icon, -i Template icon file <required>
    --manifest, -m Template webmanifest file
    --outputIcon, -oi Output icons directory path
    --outputManifest, -om Output webmanifest directory path
    --sizes, -s Output icon sizes

  Examples
    $ webmanifest
    $ webmanifest --icon public/icon.svg --manifest public/manifest.webmanifest --outputIcon public/assets --outputManifest public/manifest.webmanifest --sizes 512,384,192,180,152,144,128,96,72
  `, {
        flags: {
            icon: {
                type: 'string',
                alias: 'i',
                default: DEFAULT_INPUT_ICON_PATH,
            },
            manifest: {
                type: 'string',
                alias: 'm',
                default: DEFAULT_INPUT_MANIFEST_PATH,
            },
            outputIcon: {
                type: 'string',
                alias: 'oi',
                default: DEFAULT_OUTPUT_ICON_PATH,
            },
            outputManifest: {
                type: 'string',
                alias: 'om',
                default: DEFAULT_OUTPUT_MANIFEST_PATH,
            },
            sizes: {
                type: 'string',
                alias: 's',
                default: DEFAULT_OUTPUT_SIZES,
            },
        },
    });
    if (!(yield fs_extra_1.pathExists(cli.flags.icon))) {
        throw new Error(`${cli.flags.icon} does not exists.`);
    }
    if (!(yield fs_extra_1.pathExists(cli.flags.manifest))) {
        throw new Error(`${cli.flags.manifest} does not exists.`);
    }
    if (!(yield fs_extra_1.pathExists(cli.flags.outputIcon))) {
        throw new Error(`${cli.flags.outputIcon} does not exists.`);
    }
    if (!(yield fs_extra_1.pathExists(cli.flags.outputManifest))) {
        throw new Error(`${cli.flags.outputManifest} does not exists.`);
    }
    const iconRectangle = image_size_1.imageSize(cli.flags.icon);
    if (!iconRectangle.width || !iconRectangle.height) {
        throw new Error('Icon file is invalid.');
    }
    if (iconRectangle.width !== iconRectangle.height) {
        throw new Error('Icon file is required its square.');
    }
    if (iconRectangle.width && iconRectangle.width < MIN_ACCEPT_IMAGE_RESOLUTION) {
        throw new Error(`Icon file is required larger than ${MIN_ACCEPT_IMAGE_RESOLUTION}px.`);
    }
    if (iconRectangle.height && iconRectangle.height < MIN_ACCEPT_IMAGE_RESOLUTION) {
        throw new Error(`Icon file is required larger than ${MIN_ACCEPT_IMAGE_RESOLUTION}px.`);
    }
    const ascendingOrder = (a, b) => (a < b ? 1 : -1);
    const outputSizes = cli.flags.sizes.includes(ICON_SIZE_DELIMITER)
        ? cli.flags.sizes.split(ICON_SIZE_DELIMITER).map(Number).filter(Number).sort(ascendingOrder)
        : [Number(cli.flags.sizes)].filter(Number);
    for (const size of outputSizes) {
        yield sharp_1.default(cli.flags.icon).resize(size, size).png().toFile(`${cli.flags.outputIcon}/icon-${size}x${size}.png`);
        console.log(`Output icon: ${cli.flags.outputIcon}/icon-${size}x${size}.png`);
    }
    const inputManifest = yield fs_extra_1.readJSON(cli.flags.manifest);
    const outputManifestContent = Object.assign(Object.assign({}, inputManifest), { icons: outputSizes.map((size) => ({
            src: `icon-${size}x${size}.png`,
            sizes: `${size}x${size}`,
            type: 'image/png',
        })) });
    yield fs_extra_1.writeJSON(cli.flags.outputManifest, outputManifestContent, { spaces: 2 });
    console.log(`Output webmanifest: ${cli.flags.outputManifest}`);
    console.log('\nðŸŽ‰ All icons and webmanifest file is generated successfully.\n');
}))();
